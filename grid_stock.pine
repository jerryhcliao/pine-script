//@version=6
// =============== 策略设置 ===============
strategy("网格交易策略 - A股 (改进版)", 
     overlay=true, 
     precision=2, 
     initial_capital=200000, 
     pyramiding=40, 
     default_qty_type = strategy.fixed,
     margin_long=100,
     margin_short=100,
     process_orders_on_close=false)

// =============== 多空交易约束 ===============
// 仅允许做多
strategy.risk.allow_entry_in(strategy.direction.long)

// =============== 网格策略参数 - 普通股票 ===============
INITIAL_POSITION_AMOUNT_NORMAL = 60000.0            // 初始建仓金额(元)
EARLY_GRID_DROP_PERCENT_NORMAL = 0.05               // 普通股票前5个网格下跌百分比(%)
EARLY_TAKE_PROFIT_PERCENT_NORMAL = 0.10             // 普通股票前5个网格止盈百分比(%)
LATE_GRID_DROP_PERCENT_NORMAL = 0.10                // 普通股票超过5个网格后下跌百分比(%)
LATE_TAKE_PROFIT_PERCENT_NORMAL = 0.15              // 普通股票超过5个网格后止盈百分比(%)
EARLY_GRID_INCREASE_PERCENT_NORMAL = 0.10           // 普通股票前5个网格加仓比例(%)
LATE_GRID_INCREASE_PERCENT_NORMAL = 0.15            // 普通股票超过5个网格后加仓比例(%)
BEAR_MARKET_INCREASE_PERCENT_NORMAL = 0.20          // 普通股票超过5个网格后，熊市加仓比例(%)

// =============== 网格策略参数 - 科创板 ===============
INITIAL_POSITION_AMOUNT_SCI = 60000.0               // 初始建仓金额(元)
EARLY_GRID_DROP_PERCENT_SCI = 0.08                  // 科创板前5个网格下跌百分比(%)
EARLY_TAKE_PROFIT_PERCENT_SCI = 0.16                // 科创板前5个网格止盈百分比(%)
LATE_GRID_DROP_PERCENT_SCI = 0.14                   // 科创板超过5个网格后下跌百分比(%)
LATE_TAKE_PROFIT_PERCENT_SCI = 0.28                 // 科创板超过5个网格后止盈百分比(%)
EARLY_GRID_INCREASE_PERCENT_SCI = 0.10              // 科创板前5个网格加仓比例(%)
LATE_GRID_INCREASE_PERCENT_SCI = 0.15               // 科创板超过5个网格后加仓比例(%)
BEAR_MARKET_INCREASE_PERCENT_SCI = 0.20             // 科创板超过5个网格后，熊市加仓比例(%)

// =============== 网格策略参数 - 指数基金(ETF) ===============
INITIAL_POSITION_AMOUNT_ETF = 100000.0              // 初始建仓金额(元)
EARLY_GRID_DROP_PERCENT_ETF = 0.05                  // 指数基金前5个网格下跌百分比(%)
EARLY_TAKE_PROFIT_PERCENT_ETF = 0.10                // 指数基金前5个网格止盈百分比(%)
LATE_GRID_DROP_PERCENT_ETF = 0.10                   // 指数基金超过5个网格后下跌百分比(%)
LATE_TAKE_PROFIT_PERCENT_ETF = 0.15                 // 指数基金超过5个网格后止盈百分比(%)
EARLY_GRID_INCREASE_PERCENT_ETF = 0.10              // 指数基金前5个网格加仓比例(%)
LATE_GRID_INCREASE_PERCENT_ETF = 0.15               // 指数基金超过5个网格后加仓比例(%)
BEAR_MARKET_INCREASE_PERCENT_ETF = 0.20             // 指数基金超过5个网格后，熊市加仓比例(%)

// =============== 通用参数 ===============
MAX_GRIDS = 40                                      // 最大网格层数
COOLDOWN_PERIOD = 4                                 // 清仓后冷却K线数
REENTRY_DISCOUNT = 0.03                             // 提前重入回调幅度(%)
// 股票回测时间限制 (自2020年1月1日)
START_DATE_MS = timestamp("2020/01/01")

// =============== 调试模式参数 ===============
DEBUG_MODE = input.bool(false, "DEBUG模式", group="调试设置", tooltip="开启后显示详细的网格信息表格")

in_trading_timeframe = time > START_DATE_MS


// --- K线时间，方便调试 ---
// 获取各个时间组件
yr = year(time)
mo = month(time)
dy = dayofmonth(time)
hr = hour(time)
min = minute(time)
sec = second(time)

// 转换月、日、时、分、秒为两位数格式
mo_str = mo < 10 ? "0" + str.tostring(mo) : str.tostring(mo)
dy_str = dy < 10 ? "0" + str.tostring(dy) : str.tostring(dy)
hr_str = hr < 10 ? "0" + str.tostring(hr) : str.tostring(hr)
min_str = min < 10 ? "0" + str.tostring(min) : str.tostring(min)

// 组合成最终格式
k_formatted_time = str.tostring(yr) + mo_str + dy_str + hr_str + min_str

// =============== 网格交易状态变量 ===============
// 用数组记录每批次的买入价格、数量和ID
// 注意：网格从1开始编号，数组索引 = 网格编号
// 例如：网格1存储在数组索引1，网格2存储在数组索引2，以此类推
var float[] entry_prices = array.new_float(MAX_GRIDS + 1, 0.0)
var float[] entry_quantities = array.new_float(MAX_GRIDS + 1, 0.0)
var string[] entry_ids = array.new_string(MAX_GRIDS + 1, "")
// 记录最后一次买入价格（用于计算下一个网格）
var float current_entry_price = 0.0
// 记录下一个网格买入价格
var float next_grid_price = 0.0
// 记录当前网格止盈价格
var float current_grid_profit_price = 0.0
// 记录当前被占用的网格数量（网格从1开始编号）
var int current_slot = 0
// 记录下一个空闲的网格位置（网格从1开始编号）
var int next_slot = 1
// 时间冷却机制
var int cooldown_bars = 0
// 最后清仓价格
var float last_exit_price = 0.0
// 最大资金占用记录
var float max_capital_used = 0.0
// 当前资金占用
var float current_capital_used = 0.0
// 累计盈利金额
var float cumulative_profit = 0.0
// 是否破产（触发加仓条件但资金不足）
var bool is_bankrupt = false
// 破产日期
var string bankrupt_date = ""

// =============== 运行时网格参数（根据股票类型初始化一次）===============
// 检测是否为科创板股票（代码以688开头）
is_sci_board = str.startswith(syminfo.ticker, "688")
// 检测是否为指数基金(ETF)
etf_tickers = array.from("159632", "159915")
is_etf = array.includes(etf_tickers, syminfo.ticker)

// 根据股票类型初始化网格参数（只在第一根K线初始化一次）
var float INITIAL_POSITION_AMOUNT = 0.0
var float EARLY_GRID_DROP_PERCENT = 0.0
var float EARLY_TAKE_PROFIT_PERCENT = 0.0
var float LATE_GRID_DROP_PERCENT = 0.0
var float LATE_TAKE_PROFIT_PERCENT = 0.0
var float EARLY_GRID_INCREASE_PERCENT = 0.0
var float LATE_GRID_INCREASE_PERCENT = 0.0
var float BEAR_MARKET_INCREASE_PERCENT = 0.0
var int MIN_SHARES = 0

// 只在第一根K线时初始化参数
if barstate.isfirst
    // 根据股票类型选择参数：优先级 指数基金(ETF) > 科创板 > 普通股票
    if is_etf
        // 指数基金(ETF)参数
        INITIAL_POSITION_AMOUNT := INITIAL_POSITION_AMOUNT_ETF
        EARLY_GRID_DROP_PERCENT := EARLY_GRID_DROP_PERCENT_ETF
        EARLY_TAKE_PROFIT_PERCENT := EARLY_TAKE_PROFIT_PERCENT_ETF
        LATE_GRID_DROP_PERCENT := LATE_GRID_DROP_PERCENT_ETF
        LATE_TAKE_PROFIT_PERCENT := LATE_TAKE_PROFIT_PERCENT_ETF
        EARLY_GRID_INCREASE_PERCENT := EARLY_GRID_INCREASE_PERCENT_ETF
        LATE_GRID_INCREASE_PERCENT := LATE_GRID_INCREASE_PERCENT_ETF
        BEAR_MARKET_INCREASE_PERCENT := BEAR_MARKET_INCREASE_PERCENT_ETF
        MIN_SHARES := 100
    else if is_sci_board
        // 科创板参数
        INITIAL_POSITION_AMOUNT := INITIAL_POSITION_AMOUNT_SCI
        EARLY_GRID_DROP_PERCENT := EARLY_GRID_DROP_PERCENT_SCI
        EARLY_TAKE_PROFIT_PERCENT := EARLY_TAKE_PROFIT_PERCENT_SCI
        LATE_GRID_DROP_PERCENT := LATE_GRID_DROP_PERCENT_SCI
        LATE_TAKE_PROFIT_PERCENT := LATE_TAKE_PROFIT_PERCENT_SCI
        EARLY_GRID_INCREASE_PERCENT := EARLY_GRID_INCREASE_PERCENT_SCI
        LATE_GRID_INCREASE_PERCENT := LATE_GRID_INCREASE_PERCENT_SCI
        BEAR_MARKET_INCREASE_PERCENT := BEAR_MARKET_INCREASE_PERCENT_SCI
        MIN_SHARES := 200
    else
        // 普通股票参数
        INITIAL_POSITION_AMOUNT := INITIAL_POSITION_AMOUNT_NORMAL
        EARLY_GRID_DROP_PERCENT := EARLY_GRID_DROP_PERCENT_NORMAL
        EARLY_TAKE_PROFIT_PERCENT := EARLY_TAKE_PROFIT_PERCENT_NORMAL
        LATE_GRID_DROP_PERCENT := LATE_GRID_DROP_PERCENT_NORMAL
        LATE_TAKE_PROFIT_PERCENT := LATE_TAKE_PROFIT_PERCENT_NORMAL
        EARLY_GRID_INCREASE_PERCENT := EARLY_GRID_INCREASE_PERCENT_NORMAL
        LATE_GRID_INCREASE_PERCENT := LATE_GRID_INCREASE_PERCENT_NORMAL
        BEAR_MARKET_INCREASE_PERCENT := BEAR_MARKET_INCREASE_PERCENT_NORMAL
        MIN_SHARES := 100

// 计算当前可用现金（使用策略内置权益变量）
get_available_cash() =>
    // 可用现金 = 总权益 - 持仓市值
    strategy.equity - strategy.position_size * close

// =============== 均线系统计算 ===============
// 计算4根均线
ma1 = ta.sma(close, 25 * 4)  // 月线
ma2 = ta.sma(close, 75 * 4)  // 季线
ma3 = ta.sma(close, 125 * 4) // 半年线
ma4 = ta.sma(close, 250 * 4) // 年线

// 判断市场趋势
is_bull_market = ma1 > ma2 and ma2 > ma3 and ma3 > ma4
is_bear_market = ma1 < ma2 and ma2 < ma3 and ma3 < ma4

// 计算下一个网格买入点（根据当前网格层数使用不同参数）
calculate_next_grid_price(last_price, current_slot) =>
    drop_percent = current_slot <= 5 ? EARLY_GRID_DROP_PERCENT : LATE_GRID_DROP_PERCENT
    last_price * (1 - drop_percent)

// 计算止盈价格（根据当前网格层数使用不同参数）
calculate_take_profit_price(entry_price, current_slot) =>
    profit_percent = current_slot <= 5 ? EARLY_TAKE_PROFIT_PERCENT : LATE_TAKE_PROFIT_PERCENT
    entry_price * (1 + profit_percent)

// 计算可以买入的股数（必须是100的整数倍）
// 如果条件不允许（股数不足最小股数或资金不足），直接返回0
calculate_initial_shares(amount, price) =>
    shares = math.floor(amount / price / 100) * 100
    available_cash = get_available_cash()
    if shares >= MIN_SHARES and available_cash >= shares * price
        shares
    else
        0

// 计算加仓数量（根据当前网格层数和市场状态使用不同加仓策略）
// 如果资金不足，直接返回0
calculate_additional_shares(current_position_size, current_slot) =>
    increase_percent = 0.10
    additional_shares = 0

    if current_slot <= 5
        // 前5个网格：使用早期加仓比例
        increase_percent := EARLY_GRID_INCREASE_PERCENT
        additional_shares := math.floor(current_position_size * increase_percent / 100) * 100
        additional_shares := math.max(MIN_SHARES, additional_shares)
    else
        // 超过5个网格：根据市场状态调整加仓比例
        increase_percent := is_bear_market ? BEAR_MARKET_INCREASE_PERCENT : LATE_GRID_INCREASE_PERCENT
        additional_shares := math.floor(current_position_size * increase_percent / 100) * 100
        additional_shares := math.max(MIN_SHARES * 2, additional_shares)
    
    // 检查资金是否足够，如果不够则返回0
    available_cash = get_available_cash()
    if available_cash >= additional_shares * close
        additional_shares
    else
        0

// 计算当前所有持仓的总成本
calculate_total_capital_used() =>
    total_cost = 0.0
    for i = 1 to current_slot
        if array.get(entry_quantities, i) > 0
            total_cost := total_cost + array.get(entry_quantities, i) * array.get(entry_prices, i)
    total_cost

// 变量重置
if strategy.position_size == 0
    current_slot := 0
    next_slot := 1

// =============== 入场和加仓条件 ===============
// 每根K线减少冷却计数器
if cooldown_bars > 0
    cooldown_bars := cooldown_bars - 1

// 空仓且在交易时间内
entry_condition_1 = strategy.position_size == 0 and in_trading_timeframe

// 冷却期已过 或者 价格回调足够大
cooldown_finished = cooldown_bars <= 0
price_dropped_enough = last_exit_price > 0 and close <= last_exit_price * (1 - REENTRY_DISCOUNT)
entry_condition_2 = cooldown_finished or price_dropped_enough

// 组合条件（去掉了原来的 or true）
initial_entry_condition = entry_condition_1 and entry_condition_2

// 加仓条件（价格下跌至下一个网格点且活跃网格数小于最大值）
add_position_condition = strategy.position_size > 0 and in_trading_timeframe and close <= next_grid_price and current_slot > 0 and current_slot < MAX_GRIDS

// =============== 执行策略 ===============
// 初始建仓
if initial_entry_condition
    // 计算可以买入的股数（函数内部已包含条件检查）
    shares_to_buy = calculate_initial_shares(INITIAL_POSITION_AMOUNT, close)
    if shares_to_buy > 0
        entryId = "初始建仓"

        strategy.entry(entryId, strategy.long, qty=shares_to_buy, comment=syminfo.ticker + " 初始建仓@" + str.tostring(close))
        
        // 记录这批次的买入信息（网格1存储在数组索引1）
        array.set(entry_prices, 1, close)
        array.set(entry_quantities, 1, shares_to_buy)
        array.set(entry_ids, 1, entryId)
        
        // 记录买入价格
        current_entry_price := close
        // 更新网格状态（网格1已占用）
        current_slot := 1
        next_slot := 2
        // 计算下一个网格价格（网格2）
        next_grid_price := calculate_next_grid_price(close, current_slot)
        
        // 更新最大资金占用
        current_capital_used := calculate_total_capital_used()
        max_capital_used := math.max(max_capital_used, current_capital_used)
else if add_position_condition
    // 计算加仓数量（函数内部已包含资金检查）
    additional_shares = calculate_additional_shares(strategy.position_size, current_slot)

    // 破产检测：触发加仓条件但资金不足
    if additional_shares == 0 and not is_bankrupt
        is_bankrupt := true
        bankrupt_date := k_formatted_time

    // 网格加仓
    if additional_shares > 0
        entryId = "网格加仓#" + str.tostring(next_slot)
        strategy.entry(entryId, strategy.long, qty=additional_shares, comment = 
         syminfo.ticker + " 网格加仓#" + str.tostring(next_slot) + "@" + str.tostring(close))
        
        // 记录这批次的买入信息（网格编号直接作为数组索引）
        array.set(entry_prices, next_slot, close)
        array.set(entry_quantities, next_slot, additional_shares)
        array.set(entry_ids, next_slot, entryId)
        
        // 更新最后一次买入价格
        current_entry_price := close
        // 更新网格状态
        current_slot := next_slot
        next_slot := next_slot + 1
        // 计算下一个网格价格
        next_grid_price := calculate_next_grid_price(close, current_slot)
        
        // 更新最大资金占用
        current_capital_used := calculate_total_capital_used()
        max_capital_used := math.max(max_capital_used, current_capital_used)

// 如果有持仓，判断是否可以止盈
if current_slot > 0
    // 获取当前监控的批次信息（最后一个批次，网格编号为current_slot）
    entry_price = array.get(entry_prices, current_slot)
    entry_quantity = array.get(entry_quantities, current_slot)
    entry_id = array.get(entry_ids, current_slot)
    
    // 计算该批次的止盈价格
    current_grid_profit_price := calculate_take_profit_price(entry_price, current_slot)
    
    // 检查是否达到止盈条件
    if close >= current_grid_profit_price
        c = ""
        if current_slot > 1
            c:= syminfo.ticker + " 批次止盈#" + str.tostring(current_slot) +"@" + str.tostring(close)
        else
            c := syminfo.ticker + " 清仓@" + str.tostring(close)

        // 计算本次盈利：卖出价 × 股数 - 买入价 × 股数
        current_profit = entry_quantity * close - entry_quantity * entry_price
        // 累加到总盈利
        cumulative_profit := cumulative_profit + current_profit

        // 平掉该批次的仓位
        strategy.close(entry_id, qty=entry_quantity, comment=c)
        // 减少占用的网格数量
        current_slot := current_slot - 1
        next_slot := current_slot + 1

        current_capital_used := calculate_total_capital_used()

        if current_slot > 0
            // 回到上一级网格价格
            current_entry_price := array.get(entry_prices, current_slot)
            // 计算预期加仓价（下一个网格价格） 
            next_grid_price := calculate_next_grid_price(current_entry_price, current_slot)
            // 计算卖出价格
            current_grid_profit_price := calculate_take_profit_price(entry_price, current_slot)
        else
            cooldown_bars := COOLDOWN_PERIOD
            last_exit_price := close

// =============== 绘制价格线 ===============
// 绘制下一个网格买入价
plot(strategy.position_size > 0 ? next_grid_price : na, "下一网格买入价", color=color.new(color.blue, 0), style=plot.style_cross)
plot(strategy.position_size > 0 ? current_entry_price : na, "当前网格买入价", color=color.new(color.gray, 0), style=plot.style_cross)
plot(strategy.position_size > 0 ? current_grid_profit_price : na, "当前网格止盈价", color=color.new(color.red, 0), style=plot.style_cross)

// =============== 绘制均线系统 ===============
// 绘制均线
plot(ma1, "MA100", color=color.new(#D3D3D3, 0), linewidth=1)  // 浅灰色
plot(ma2, "MA300", color=color.new(#A9A9A9, 0), linewidth=1)  // 深灰色
plot(ma3, "MA500", color=color.new(#808080, 0), linewidth=1)  // 灰色
plot(ma4, "MA1000", color=color.new(#696969, 0), linewidth=1) // 暗灰色

// =============== 信息显示 ===============
// 生成DEBUG模式下的表格内容
get_debug_table_content() =>
    table_content = ""
    
    if DEBUG_MODE and current_slot > 0 and barstate.islastconfirmedhistory
        // 表格标题
        table_content := "Slot | 买入价 | 股数 | 预期卖出价 | 预期加仓价\n"
        table_content := table_content + "-----|--------|------|------------|------------\n"
        
        // 遍历所有活跃的Slot（网格从1开始编号）
        for i = 1 to current_slot
            entry_price = array.get(entry_prices, i)
            entry_quantity = array.get(entry_quantities, i)
            
            if entry_quantity > 0
                grid_number = i  // 网格编号就是循环变量i
                // 计算预期卖出价
                expected_sell_price = calculate_take_profit_price(entry_price, grid_number)
                // 计算预期加仓价（下一个网格价格）
                expected_add_price = calculate_next_grid_price(entry_price, grid_number)
                
                table_content := table_content + 
                     str.tostring(grid_number) + " | " + 
                     str.tostring(math.round(entry_price, 2)) + " | " + 
                     str.tostring(math.round(entry_quantity)) + " | " + 
                     str.tostring(math.round(expected_sell_price, 2)) + " | " + 
                     str.tostring(math.round(expected_add_price, 2)) + "\n"
    
    table_content

if barstate.islastconfirmedhistory
    var label info = label.new(bar_index, na, "", color=color.blue, style=label.style_label_left, textcolor=color.white)

    label.set_xy(info, bar_index, high)
    // 市场趋势文字
    market_trend_text = is_bull_market ? "🐂 牛市" : is_bear_market ? "🐻 熊市" : "📊 震荡市"
    // 破产状态文字
    bankrupt_text = is_bankrupt ? "⚠️ 已破产" : "✅ 正常"
    // 破产日期文字（仅在破产时显示）
    bankrupt_date_text = is_bankrupt ? "\n破产日期：" + bankrupt_date : ""

    label.set_text(info, "网格交易策略" + 
         "\n\n价值：" + str.tostring(math.round(strategy.position_size * close)) + 
         "\n最大资金占用：" + str.tostring(math.round(max_capital_used)) +
         "\n当前资金占用：" + str.tostring(math.round(current_capital_used)) +
         "\n现金余额：" + str.tostring(math.round(get_available_cash())) + 
         "\n资金状态：" + bankrupt_text + bankrupt_date_text +
         "\n累计盈利：" + str.tostring(math.round(cumulative_profit)) +
         "\n持仓：" + str.tostring(strategy.position_size) +
         "\nSlot：" + str.tostring(current_slot) + "|" + str.tostring(math.round(strategy.position_avg_price,2)) +
         "\n市场趋势：" + market_trend_text )


// 根据DEBUG模式显示不同内容
if DEBUG_MODE and barstate.islastconfirmedhistory
    var table debug_table = table.new(position.top_right, 5, MAX_GRIDS + 2, bgcolor=color.white, border_width=1)

    // DEBUG模式：显示表格
    table.clear(debug_table, 0, 0, 4, MAX_GRIDS + 1)
    
    // 设置表格标题
    table.cell(debug_table, 0, 0, "Slot", text_color=color.black, bgcolor=color.gray)
    table.cell(debug_table, 1, 0, "买入价", text_color=color.black, bgcolor=color.gray)
    table.cell(debug_table, 2, 0, "股数", text_color=color.black, bgcolor=color.gray)
    table.cell(debug_table, 3, 0, "预期卖出价", text_color=color.black, bgcolor=color.gray)
    table.cell(debug_table, 4, 0, "预期加仓价", text_color=color.black, bgcolor=color.gray)
    
    // 填充数据行（网格从1开始编号）
    if current_slot > 0
        for i = 1 to current_slot
            entry_price = array.get(entry_prices, i)
            entry_quantity = array.get(entry_quantities, i)
            
            if entry_quantity > 0
                row = i  // 表格行号 = 网格编号
                grid_number = i  // 网格编号就是循环变量i
                expected_sell_price = calculate_take_profit_price(entry_price, grid_number)
                expected_add_price = calculate_next_grid_price(entry_price, grid_number)
                
                table.cell(debug_table, 0, row, str.tostring(grid_number), text_color=color.black)
                table.cell(debug_table, 1, row, str.tostring(math.round(entry_price, 2)), text_color=color.black)
                table.cell(debug_table, 2, row, str.tostring(math.round(entry_quantity)), text_color=color.black)
                table.cell(debug_table, 3, row, str.tostring(math.round(expected_sell_price, 2)), text_color=color.black)
                table.cell(debug_table, 4, row, str.tostring(math.round(expected_add_price, 2)), text_color=color.black)