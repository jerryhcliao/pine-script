//@version=6
// =============== 策略设置 ===============
strategy("网格交易策略 - A股 (改进版)", 
     overlay=true, 
     precision=2, 
     initial_capital=1000000, 
     pyramiding=40, 
     default_qty_type = strategy.fixed,
     margin_long=100,
     margin_short=100,
     process_orders_on_close=true)

// =============== 多空交易约束 ===============
// 仅允许做多
strategy.risk.allow_entry_in(strategy.direction.long)

// =============== 网格策略参数 ===============
initial_position_amount = input.float(60000, "初始建仓金额(元)", minval=1000, group="网格设置")
// 前5个网格参数
early_grid_drop_percent = input.float(5.0, "前5个网格下跌百分比(%)", minval=1.0, step=0.5, group="网格设置") * 0.01
early_take_profit_percent = input.float(10.0, "前5个网格止盈百分比(%)", minval=1.0, step=0.5, group="网格设置") * 0.01
// 超过5个网格后的参数
late_grid_drop_percent = input.float(10.0, "超过5个网格后下跌百分比(%)", minval=1.0, step=0.5, group="网格设置") * 0.01
late_take_profit_percent = input.float(15.0, "超过5个网格后止盈百分比(%)", minval=1.0, step=0.5, group="网格设置") * 0.01
// 分层加仓比例参数
early_grid_increase_percent = input.float(10.0, "前5个网格加仓比例(%)", minval=1.0, step=1.0, group="网格设置") * 0.01
late_grid_increase_percent = input.float(15.0, "超过5个网格后加仓比例(%)", minval=1.0, step=1.0, group="网格设置") * 0.01
max_grids = input.int(40, "最大网格层数", minval=1, maxval=40, group="网格设置")
cooldown_period = input.int(4, "清仓后冷却K线数", minval=0, maxval=20, group="网格设置")
reentry_discount = input.float(3.0, "提前重入回调幅度(%)", minval=1.0, step=0.5, group="网格设置") * 0.01

// =============== A股特有设置 ===============
five_year_limitation = input.bool(true, "仅在最近5年内交易", group="A股特有设置")

// 股票回测时间限制 (5年)
fiveYearsInMs = 5 * 365 * 24 * 60 * 60 * 1000
in_trading_timeframe = not five_year_limitation or time > (timenow - fiveYearsInMs)

// --- K线时间，方便调试 ---
// 获取各个时间组件
yr = year(time)
mo = month(time)
dy = dayofmonth(time)
hr = hour(time)
min = minute(time)
sec = second(time)

// 转换月、日、时、分、秒为两位数格式
mo_str = mo < 10 ? "0" + str.tostring(mo) : str.tostring(mo)
dy_str = dy < 10 ? "0" + str.tostring(dy) : str.tostring(dy)
hr_str = hr < 10 ? "0" + str.tostring(hr) : str.tostring(hr)
min_str = min < 10 ? "0" + str.tostring(min) : str.tostring(min)

// 组合成最终格式
k_formatted_time = str.tostring(yr) + mo_str + dy_str + hr_str + min_str

// =============== 网格交易状态变量 ===============
// 用数组记录每批次的买入价格、数量和ID
var float[] entry_prices = array.new_float(max_grids, 0.0)
var float[] entry_quantities = array.new_float(max_grids, 0.0)
var string[] entry_ids = array.new_string(max_grids, "")

var float available_cash = strategy.initial_capital
// 记录最后一次买入价格（用于计算下一个网格）
var float last_entry_price = 0.0
// 记录下一个网格买入价格
var float next_grid_price = 0.0
// 记录当前网格止盈价格
var float current_grid_profit_price = 0.0
// 记录当前活跃的网格
var int next_slot = 0
// 时间冷却机制
var int cooldown_bars = 0
// 最后清仓价格
var float last_exit_price = 0.0



// =============== 辅助函数 ===============
// 计算可以买入的股数（必须是100的整数倍）
calculate_shares(amount, price) =>
    math.floor(amount / price / 100) * 100

// 计算下一个网格买入点（根据当前网格层数使用不同参数）
calculate_next_grid_price(last_price, current_slot) =>
    // 前5个网格使用较小的下跌幅度，超过5个网格使用较大的下跌幅度
    drop_percent = current_slot < 5 ? early_grid_drop_percent : late_grid_drop_percent
    last_price * (1 - drop_percent)

// 计算止盈价格（根据当前网格层数使用不同参数）
calculate_take_profit_price(entry_price, current_slot) =>
    // 前5个网格使用较小的止盈幅度，超过5个网格使用较大的止盈幅度
    profit_percent = current_slot < 5 ? early_take_profit_percent : late_take_profit_percent
    entry_price * (1 + profit_percent)

// 计算加仓数量（根据当前网格层数使用不同加仓比例）
calculate_additional_shares(current_position_size, current_slot) =>
    // 前5个网格使用较小的加仓比例，超过5个网格使用较大的加仓比例
    increase_percent = current_slot < 5 ? early_grid_increase_percent : late_grid_increase_percent
    additional_shares = math.max(100, math.floor(current_position_size * increase_percent / 100) * 100)
    additional_shares < 100 ? 100 : additional_shares

// 变量重置
if strategy.position_size == 0
    next_slot := 0

// =============== 入场和加仓条件 ===============
// 每根K线减少冷却计数器
if cooldown_bars > 0
    cooldown_bars := cooldown_bars - 1

// 空仓且在交易时间内
entry_condition_1 = strategy.position_size == 0 and in_trading_timeframe

// 冷却期已过 或者 价格回调足够大
cooldown_finished = cooldown_bars <= 0
price_dropped_enough = last_exit_price > 0 and close <= last_exit_price * (1 - reentry_discount)
entry_condition_2 = cooldown_finished or price_dropped_enough

// 组合条件（去掉了原来的 or true）
initial_entry_condition = entry_condition_1 and entry_condition_2

// 加仓条件（价格下跌至下一个网格点且活跃网格数小于最大值）
add_position_condition = strategy.position_size > 0 and in_trading_timeframe and close <= next_grid_price and next_slot > 0 and next_slot < max_grids

// =============== 执行策略 ===============
// 初始建仓
if initial_entry_condition
    // 计算可以买入的股数
    shares_to_buy = calculate_shares(initial_position_amount, close)
    // 确保至少可以买入100股
    if shares_to_buy >= 100 and available_cash >= shares_to_buy * close  
        entryId = "初始建仓"

        strategy.entry(entryId, strategy.long, qty=shares_to_buy, comment=syminfo.ticker + " 初始建仓@" + str.tostring(close))
        
        // 记录这批次的买入信息
        array.set(entry_prices, 0, close)
        array.set(entry_quantities, 0, shares_to_buy)
        array.set(entry_ids, 0, entryId)
        
        // 记录现金余额
        available_cash := available_cash - shares_to_buy * close
        // 记录买入价格
        last_entry_price := close
        // 计算下一个网格价格
        next_grid_price := calculate_next_grid_price(close, next_slot)
        // 递增网格
        next_slot := next_slot + 1
else if add_position_condition
    // 计算加仓数量（根据当前网格层数使用不同加仓比例）
    additional_shares = calculate_additional_shares(strategy.position_size, next_slot)

    // 网格加仓
    if available_cash >= additional_shares * close
        entryId = "网格加仓#" + str.tostring(next_slot)
        strategy.entry(entryId, strategy.long, qty=additional_shares, comment = 
         syminfo.ticker + " 网格加仓#" + str.tostring(next_slot) + "@" + str.tostring(close))
        
        // 记录这批次的买入信息
        array.set(entry_prices, next_slot, close)
        array.set(entry_quantities, next_slot, additional_shares)
        array.set(entry_ids, next_slot, entryId)
        
        // 记录现金余额
        available_cash := available_cash - additional_shares * close
        // 更新最后一次买入价格
        last_entry_price := close
        // 计算下一个网格价格
        next_grid_price := calculate_next_grid_price(close, next_slot)
        // 递增网格
        next_slot := next_slot + 1

// 如果有持仓，判断是否可以止盈
if next_slot > 0
    target_slot = next_slot - 1
    // 获取该批次的信息
    entry_price = array.get(entry_prices, target_slot)
    entry_quantity = array.get(entry_quantities, target_slot)
    entry_id = array.get(entry_ids, target_slot)
    
    // 计算该批次的止盈价格
    current_grid_profit_price := calculate_take_profit_price(entry_price, target_slot)
    
    // 检查是否达到止盈条件
    if close >= current_grid_profit_price
        c = ""
        if next_slot > 1
            c:= syminfo.ticker + " 批次止盈#" + str.tostring(target_slot) +"@" + str.tostring(close)
        else
            c := syminfo.ticker + " 清仓@" + str.tostring(close)

        // 平掉该批次的仓位
        strategy.close(entry_id, qty=entry_quantity, comment=c)
        // 更新现金余额
        available_cash := available_cash + entry_quantity * close
        // 恢复该网格
        next_slot := next_slot - 1
        
        // 回到上一级网格价格
        last_entry_price := close
        next_grid_price := calculate_next_grid_price(last_entry_price, next_slot)
        

        if next_slot > 0
            // 对买入价进行调整，以响应实际卖出价
            array.set(entry_prices, next_slot, close)
        else
            cooldown_bars := cooldown_period
            last_exit_price := close

// =============== 绘制价格线 ===============
// 绘制下一个网格买入价
plot(strategy.position_size > 0 ? next_grid_price : na, "下一网格买入价", color=color.new(color.blue, 0), style=plot.style_cross)
plot(strategy.position_size > 0 ? last_entry_price : na, "当前网格买入价", color=color.new(color.gray, 0), style=plot.style_cross)
plot(strategy.position_size > 0 ? current_grid_profit_price : na, "当前网格止盈价", color=color.new(color.red, 0), style=plot.style_cross)

// =============== 信息显示 ===============
var label info = label.new(bar_index, na, "", color=color.blue, style=label.style_label_left, textcolor=color.white)

label.set_xy(info, bar_index, high)
label.set_text(info, "网格交易策略" + 
     "\n\n价值：" + str.tostring(math.round(strategy.position_size * close)) + 
     "\n现金流：" + str.tostring(math.round(available_cash)) + 
     "\n浮盈：" + str.tostring(math.round(strategy.openprofit)) + 
     "\n持仓：" + str.tostring(strategy.position_size) +
     "\nSlot：" + str.tostring(next_slot) + "|" + str.tostring(math.round(strategy.position_avg_price,2)))