//@version=6
// =============== 策略设置 ===============
strategy("期货网格交易策略 - 简化版", 
     overlay=true, 
     precision=2, 
     initial_capital=100000, 
     pyramiding=40, 
     default_qty_type = strategy.fixed,
     margin_long=100,
     margin_short=100,
     process_orders_on_close=true)

// =============== 多空交易约束 ===============
// 仅允许做多
strategy.risk.allow_entry_in(strategy.direction.long)

// =============== 网格策略参数 ===============
fixed_qty = 2  // 固定每次交易2手
grid_drop_percent = input.float(5.0, "网格下跌百分比(%)", minval=1.0, step=0.5, group="网格设置") * 0.01
take_profit_percent = input.float(10.0, "止盈百分比(%)", minval=1.0, step=0.5, group="网格设置") * 0.01
max_grids = input.int(20, "最大网格层数", minval=1, maxval=40, group="网格设置")

// =============== 网格交易状态变量 ===============
// 用数组记录每批次的买入价格和ID
var float[] entry_prices = array.new_float(max_grids, 0.0)
var string[] entry_ids = array.new_string(max_grids, "")

var float highest_equity = strategy.initial_capital
// 记录最后一次买入价格（用于计算下一个网格）
var float last_entry_price = 0.0
// 记录下一个网格买入价格
var float next_grid_price = 0.0
// 记录当前网格止盈价格
var float current_grid_profit_price = 0.0
// 记录当前活跃的网格
var int next_slot = 0

// =============== 辅助函数 ===============
// 计算下一个网格买入点
calculate_next_grid_price(last_price) =>
    last_price * (1 - grid_drop_percent)

// 更新最高净值（用于回撤计算）
current_equity = strategy.equity
if current_equity > highest_equity
    highest_equity := current_equity

// 变量重置
if strategy.position_size == 0
    next_slot := 0

// =============== 入场和加仓条件 ===============
// 空仓时的入场条件
initial_entry_condition = strategy.position_size == 0

// 加仓条件（价格下跌至下一个网格点且活跃网格数小于最大值）
add_position_condition = strategy.position_size > 0 and close <= next_grid_price and next_slot > 0 and next_slot < max_grids

// =============== 执行策略 ===============
// 初始建仓
if initial_entry_condition
    entryId = "初始建仓"
    strategy.entry(entryId, strategy.long, qty=fixed_qty, comment="初始建仓@" + str.tostring(close))
    
    // 记录这批次的买入信息
    array.set(entry_prices, 0, close)
    array.set(entry_ids, 0, entryId)
    
    // 记录买入价格
    last_entry_price := close
    // 计算下一个网格价格
    next_grid_price := calculate_next_grid_price(close)
    // 递增网格
    next_slot := next_slot + 1

else if add_position_condition
    // 网格加仓 - 固定2手
    entryId = "网格加仓#" + str.tostring(next_slot)
    strategy.entry(entryId, strategy.long, qty=fixed_qty, comment="网格加仓#" + str.tostring(next_slot) + "@" + str.tostring(close))
    
    // 记录这批次的买入信息
    array.set(entry_prices, next_slot, close)
    array.set(entry_ids, next_slot, entryId)
    
    // 更新最后一次买入价格
    last_entry_price := close
    // 计算下一个网格价格
    next_grid_price := calculate_next_grid_price(close)
    // 递增网格
    next_slot := next_slot + 1

// 止盈逻辑
if next_slot > 0
    target_slot = next_slot - 1
    // 获取该批次的信息
    entry_price = array.get(entry_prices, target_slot)
    entry_id = array.get(entry_ids, target_slot)
    
    // 计算该批次的止盈价格
    current_grid_profit_price := entry_price * (1 + take_profit_percent)
    
    // 检查是否达到止盈条件
    if close >= current_grid_profit_price
        comment_text = if next_slot > 1
            "批次止盈#" + str.tostring(target_slot) + "@" + str.tostring(close)
        else
            "清仓@" + str.tostring(close)

        // 平掉该批次的仓位 - 固定2手
        strategy.close(entry_id, qty=fixed_qty, comment=comment_text)
        
        // 恢复该网格
        next_slot := next_slot - 1
        
        // 重新计算网格价格
        if next_slot > 0
            last_entry_price := close
            next_grid_price := calculate_next_grid_price(last_entry_price)

// =============== 绘制价格线 ===============
// 绘制关键价格线
plot(strategy.position_size > 0 ? next_grid_price : na, "下一网格买入价", color=color.new(color.blue, 0), style=plot.style_cross)
plot(strategy.position_size > 0 ? last_entry_price : na, "最后买入价", color=color.new(color.gray, 0), style=plot.style_cross)
plot(strategy.position_size > 0 ? current_grid_profit_price : na, "当前止盈价", color=color.new(color.red, 0), style=plot.style_cross)

// =============== 信息显示 ===============
var table info_table = table.new(position.top_right, 2, 6, bgcolor=color.white, border_width=1)

if barstate.islast
    table.cell(info_table, 0, 0, "持仓数量", text_color=color.black)
    table.cell(info_table, 1, 0, str.tostring(strategy.position_size) + "手", text_color=color.black)
    table.cell(info_table, 0, 1, "浮动盈亏", text_color=color.black)
    table.cell(info_table, 1, 1, str.tostring(math.round(strategy.openprofit)), text_color=color.black)
    table.cell(info_table, 0, 2, "活跃网格", text_color=color.black)
    table.cell(info_table, 1, 2, str.tostring(next_slot), text_color=color.black)
    table.cell(info_table, 0, 3, "平均成本", text_color=color.black)
    table.cell(info_table, 1, 3, str.tostring(math.round(strategy.position_avg_price, 2)), text_color=color.black)